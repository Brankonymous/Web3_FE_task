{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BLAKE2 = exports.SIGMA = void 0;\nconst _assert_js_1 = require(\"./_assert.js\");\nconst utils_js_1 = require(\"./utils.js\");\n// For BLAKE2b, the two extra permutations for rounds 10 and 11 are SIGMA[10..11] = SIGMA[0..1].\n// prettier-ignore\nexports.SIGMA = new Uint8Array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3, 11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4, 7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8, 9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13, 2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9, 12, 5, 1, 15, 14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8, 11, 13, 11, 7, 14, 12, 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10, 6, 15, 14, 9, 11, 3, 0, 8, 12, 2, 13, 7, 1, 4, 10, 5, 10, 2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3]);\nclass BLAKE2 extends utils_js_1.Hash {\n  constructor(blockLen, outputLen, opts = {}, keyLen, saltLen, persLen) {\n    super();\n    this.blockLen = blockLen;\n    this.outputLen = outputLen;\n    this.length = 0;\n    this.pos = 0;\n    this.finished = false;\n    this.destroyed = false;\n    _assert_js_1.default.number(blockLen);\n    _assert_js_1.default.number(outputLen);\n    _assert_js_1.default.number(keyLen);\n    if (outputLen < 0 || outputLen > keyLen) throw new Error('outputLen bigger than keyLen');\n    if (opts.key !== undefined && (opts.key.length < 1 || opts.key.length > keyLen)) throw new Error(`key must be up 1..${keyLen} byte long or undefined`);\n    if (opts.salt !== undefined && opts.salt.length !== saltLen) throw new Error(`salt must be ${saltLen} byte long or undefined`);\n    if (opts.personalization !== undefined && opts.personalization.length !== persLen) throw new Error(`personalization must be ${persLen} byte long or undefined`);\n    this.buffer32 = (0, utils_js_1.u32)(this.buffer = new Uint8Array(blockLen));\n  }\n  update(data) {\n    _assert_js_1.default.exists(this);\n    // Main difference with other hashes: there is flag for last block,\n    // so we cannot process current block before we know that there\n    // is the next one. This significantly complicates logic and reduces ability\n    // to do zero-copy processing\n    const {\n      blockLen,\n      buffer,\n      buffer32\n    } = this;\n    data = (0, utils_js_1.toBytes)(data);\n    const len = data.length;\n    const offset = data.byteOffset;\n    const buf = data.buffer;\n    for (let pos = 0; pos < len;) {\n      // If buffer is full and we still have input (don't process last block, same as blake2s)\n      if (this.pos === blockLen) {\n        this.compress(buffer32, 0, false);\n        this.pos = 0;\n      }\n      const take = Math.min(blockLen - this.pos, len - pos);\n      const dataOffset = offset + pos;\n      // full block && aligned to 4 bytes && not last in input\n      if (take === blockLen && !(dataOffset % 4) && pos + take < len) {\n        const data32 = new Uint32Array(buf, dataOffset, Math.floor((len - pos) / 4));\n        for (let pos32 = 0; pos + blockLen < len; pos32 += buffer32.length, pos += blockLen) {\n          this.length += blockLen;\n          this.compress(data32, pos32, false);\n        }\n        continue;\n      }\n      buffer.set(data.subarray(pos, pos + take), this.pos);\n      this.pos += take;\n      this.length += take;\n      pos += take;\n    }\n    return this;\n  }\n  digestInto(out) {\n    _assert_js_1.default.exists(this);\n    _assert_js_1.default.output(out, this);\n    const {\n      pos,\n      buffer32\n    } = this;\n    this.finished = true;\n    // Padding\n    this.buffer.subarray(pos).fill(0);\n    this.compress(buffer32, 0, true);\n    const out32 = (0, utils_js_1.u32)(out);\n    this.get().forEach((v, i) => out32[i] = v);\n  }\n  digest() {\n    const {\n      buffer,\n      outputLen\n    } = this;\n    this.digestInto(buffer);\n    const res = buffer.slice(0, outputLen);\n    this.destroy();\n    return res;\n  }\n  _cloneInto(to) {\n    const {\n      buffer,\n      length,\n      finished,\n      destroyed,\n      outputLen,\n      pos\n    } = this;\n    to || (to = new this.constructor({\n      dkLen: outputLen\n    }));\n    to.set(...this.get());\n    to.length = length;\n    to.finished = finished;\n    to.destroyed = destroyed;\n    to.outputLen = outputLen;\n    to.buffer.set(buffer);\n    to.pos = pos;\n    return to;\n  }\n}\nexports.BLAKE2 = BLAKE2;","map":{"version":3,"names":["_assert_js_1","require","utils_js_1","exports","SIGMA","Uint8Array","BLAKE2","Hash","constructor","blockLen","outputLen","opts","keyLen","saltLen","persLen","length","pos","finished","destroyed","default","number","Error","key","undefined","salt","personalization","buffer32","u32","buffer","update","data","exists","toBytes","len","offset","byteOffset","buf","compress","take","Math","min","dataOffset","data32","Uint32Array","floor","pos32","set","subarray","digestInto","out","output","fill","out32","get","forEach","v","i","digest","res","slice","destroy","_cloneInto","to","dkLen"],"sources":["/Users/branko/Documents/Web3_FE_task/node_modules/@noble/hashes/src/_blake2.ts"],"sourcesContent":["import assert from './_assert.js';\nimport { Hash, Input, toBytes, u32 } from './utils.js';\n// For BLAKE2b, the two extra permutations for rounds 10 and 11 are SIGMA[10..11] = SIGMA[0..1].\n// prettier-ignore\nexport const SIGMA = new Uint8Array([\n  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n  14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3,\n  11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4,\n  7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8,\n  9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13,\n  2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9,\n  12, 5, 1, 15, 14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8, 11,\n  13, 11, 7, 14, 12, 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10,\n  6, 15, 14, 9, 11, 3, 0, 8, 12, 2, 13, 7, 1, 4, 10, 5,\n  10, 2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13, 0,\n  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n  14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3,\n]);\n\nexport type BlakeOpts = {\n  dkLen?: number;\n  key?: Input;\n  salt?: Input;\n  personalization?: Input;\n};\n\nexport abstract class BLAKE2<T extends BLAKE2<T>> extends Hash<T> {\n  protected abstract compress(msg: Uint32Array, offset: number, isLast: boolean): void;\n  protected abstract get(): number[];\n  protected abstract set(...args: number[]): void;\n  abstract destroy(): void;\n  protected buffer: Uint8Array;\n  protected buffer32: Uint32Array;\n  protected length: number = 0;\n  protected pos: number = 0;\n  protected finished = false;\n  protected destroyed = false;\n\n  constructor(\n    readonly blockLen: number,\n    public outputLen: number,\n    opts: BlakeOpts = {},\n    keyLen: number,\n    saltLen: number,\n    persLen: number\n  ) {\n    super();\n    assert.number(blockLen);\n    assert.number(outputLen);\n    assert.number(keyLen);\n    if (outputLen < 0 || outputLen > keyLen) throw new Error('outputLen bigger than keyLen');\n    if (opts.key !== undefined && (opts.key.length < 1 || opts.key.length > keyLen))\n      throw new Error(`key must be up 1..${keyLen} byte long or undefined`);\n    if (opts.salt !== undefined && opts.salt.length !== saltLen)\n      throw new Error(`salt must be ${saltLen} byte long or undefined`);\n    if (opts.personalization !== undefined && opts.personalization.length !== persLen)\n      throw new Error(`personalization must be ${persLen} byte long or undefined`);\n    this.buffer32 = u32((this.buffer = new Uint8Array(blockLen)));\n  }\n  update(data: Input) {\n    assert.exists(this);\n    // Main difference with other hashes: there is flag for last block,\n    // so we cannot process current block before we know that there\n    // is the next one. This significantly complicates logic and reduces ability\n    // to do zero-copy processing\n    const { blockLen, buffer, buffer32 } = this;\n    data = toBytes(data);\n    const len = data.length;\n    const offset = data.byteOffset;\n    const buf = data.buffer;\n    for (let pos = 0; pos < len; ) {\n      // If buffer is full and we still have input (don't process last block, same as blake2s)\n      if (this.pos === blockLen) {\n        this.compress(buffer32, 0, false);\n        this.pos = 0;\n      }\n      const take = Math.min(blockLen - this.pos, len - pos);\n      const dataOffset = offset + pos;\n      // full block && aligned to 4 bytes && not last in input\n      if (take === blockLen && !(dataOffset % 4) && pos + take < len) {\n        const data32 = new Uint32Array(buf, dataOffset, Math.floor((len - pos) / 4));\n        for (let pos32 = 0; pos + blockLen < len; pos32 += buffer32.length, pos += blockLen) {\n          this.length += blockLen;\n          this.compress(data32, pos32, false);\n        }\n        continue;\n      }\n      buffer.set(data.subarray(pos, pos + take), this.pos);\n      this.pos += take;\n      this.length += take;\n      pos += take;\n    }\n    return this;\n  }\n  digestInto(out: Uint8Array) {\n    assert.exists(this);\n    assert.output(out, this);\n    const { pos, buffer32 } = this;\n    this.finished = true;\n    // Padding\n    this.buffer.subarray(pos).fill(0);\n    this.compress(buffer32, 0, true);\n    const out32 = u32(out);\n    this.get().forEach((v, i) => (out32[i] = v));\n  }\n  digest() {\n    const { buffer, outputLen } = this;\n    this.digestInto(buffer);\n    const res = buffer.slice(0, outputLen);\n    this.destroy();\n    return res;\n  }\n  _cloneInto(to?: T): T {\n    const { buffer, length, finished, destroyed, outputLen, pos } = this;\n    to ||= new (this.constructor as any)({ dkLen: outputLen }) as T;\n    to.set(...this.get());\n    to.length = length;\n    to.finished = finished;\n    to.destroyed = destroyed;\n    to.outputLen = outputLen;\n    to.buffer.set(buffer);\n    to.pos = pos;\n    return to;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}