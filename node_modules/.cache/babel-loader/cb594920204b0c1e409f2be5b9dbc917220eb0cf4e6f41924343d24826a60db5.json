{"ast":null,"code":"import assert from './_assert.js';\nimport { Hash, toBytes, u32 } from './utils.js';\n// For BLAKE2b, the two extra permutations for rounds 10 and 11 are SIGMA[10..11] = SIGMA[0..1].\n// prettier-ignore\nexport const SIGMA = new Uint8Array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3, 11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4, 7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8, 9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13, 2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9, 12, 5, 1, 15, 14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8, 11, 13, 11, 7, 14, 12, 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10, 6, 15, 14, 9, 11, 3, 0, 8, 12, 2, 13, 7, 1, 4, 10, 5, 10, 2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3]);\nexport class BLAKE2 extends Hash {\n  constructor(blockLen, outputLen, opts = {}, keyLen, saltLen, persLen) {\n    super();\n    this.blockLen = blockLen;\n    this.outputLen = outputLen;\n    this.length = 0;\n    this.pos = 0;\n    this.finished = false;\n    this.destroyed = false;\n    assert.number(blockLen);\n    assert.number(outputLen);\n    assert.number(keyLen);\n    if (outputLen < 0 || outputLen > keyLen) throw new Error('outputLen bigger than keyLen');\n    if (opts.key !== undefined && (opts.key.length < 1 || opts.key.length > keyLen)) throw new Error(`key must be up 1..${keyLen} byte long or undefined`);\n    if (opts.salt !== undefined && opts.salt.length !== saltLen) throw new Error(`salt must be ${saltLen} byte long or undefined`);\n    if (opts.personalization !== undefined && opts.personalization.length !== persLen) throw new Error(`personalization must be ${persLen} byte long or undefined`);\n    this.buffer32 = u32(this.buffer = new Uint8Array(blockLen));\n  }\n  update(data) {\n    assert.exists(this);\n    // Main difference with other hashes: there is flag for last block,\n    // so we cannot process current block before we know that there\n    // is the next one. This significantly complicates logic and reduces ability\n    // to do zero-copy processing\n    const {\n      blockLen,\n      buffer,\n      buffer32\n    } = this;\n    data = toBytes(data);\n    const len = data.length;\n    const offset = data.byteOffset;\n    const buf = data.buffer;\n    for (let pos = 0; pos < len;) {\n      // If buffer is full and we still have input (don't process last block, same as blake2s)\n      if (this.pos === blockLen) {\n        this.compress(buffer32, 0, false);\n        this.pos = 0;\n      }\n      const take = Math.min(blockLen - this.pos, len - pos);\n      const dataOffset = offset + pos;\n      // full block && aligned to 4 bytes && not last in input\n      if (take === blockLen && !(dataOffset % 4) && pos + take < len) {\n        const data32 = new Uint32Array(buf, dataOffset, Math.floor((len - pos) / 4));\n        for (let pos32 = 0; pos + blockLen < len; pos32 += buffer32.length, pos += blockLen) {\n          this.length += blockLen;\n          this.compress(data32, pos32, false);\n        }\n        continue;\n      }\n      buffer.set(data.subarray(pos, pos + take), this.pos);\n      this.pos += take;\n      this.length += take;\n      pos += take;\n    }\n    return this;\n  }\n  digestInto(out) {\n    assert.exists(this);\n    assert.output(out, this);\n    const {\n      pos,\n      buffer32\n    } = this;\n    this.finished = true;\n    // Padding\n    this.buffer.subarray(pos).fill(0);\n    this.compress(buffer32, 0, true);\n    const out32 = u32(out);\n    this.get().forEach((v, i) => out32[i] = v);\n  }\n  digest() {\n    const {\n      buffer,\n      outputLen\n    } = this;\n    this.digestInto(buffer);\n    const res = buffer.slice(0, outputLen);\n    this.destroy();\n    return res;\n  }\n  _cloneInto(to) {\n    const {\n      buffer,\n      length,\n      finished,\n      destroyed,\n      outputLen,\n      pos\n    } = this;\n    to || (to = new this.constructor({\n      dkLen: outputLen\n    }));\n    to.set(...this.get());\n    to.length = length;\n    to.finished = finished;\n    to.destroyed = destroyed;\n    to.outputLen = outputLen;\n    to.buffer.set(buffer);\n    to.pos = pos;\n    return to;\n  }\n}","map":{"version":3,"names":["assert","Hash","toBytes","u32","SIGMA","Uint8Array","BLAKE2","constructor","blockLen","outputLen","opts","keyLen","saltLen","persLen","length","pos","finished","destroyed","number","Error","key","undefined","salt","personalization","buffer32","buffer","update","data","exists","len","offset","byteOffset","buf","compress","take","Math","min","dataOffset","data32","Uint32Array","floor","pos32","set","subarray","digestInto","out","output","fill","out32","get","forEach","v","i","digest","res","slice","destroy","_cloneInto","to","dkLen"],"sources":["/Users/branko/Documents/Web3_FE_task/node_modules/@noble/hashes/src/_blake2.ts"],"sourcesContent":["import assert from './_assert.js';\nimport { Hash, Input, toBytes, u32 } from './utils.js';\n// For BLAKE2b, the two extra permutations for rounds 10 and 11 are SIGMA[10..11] = SIGMA[0..1].\n// prettier-ignore\nexport const SIGMA = new Uint8Array([\n  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n  14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3,\n  11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4,\n  7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8,\n  9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13,\n  2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9,\n  12, 5, 1, 15, 14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8, 11,\n  13, 11, 7, 14, 12, 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10,\n  6, 15, 14, 9, 11, 3, 0, 8, 12, 2, 13, 7, 1, 4, 10, 5,\n  10, 2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13, 0,\n  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n  14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3,\n]);\n\nexport type BlakeOpts = {\n  dkLen?: number;\n  key?: Input;\n  salt?: Input;\n  personalization?: Input;\n};\n\nexport abstract class BLAKE2<T extends BLAKE2<T>> extends Hash<T> {\n  protected abstract compress(msg: Uint32Array, offset: number, isLast: boolean): void;\n  protected abstract get(): number[];\n  protected abstract set(...args: number[]): void;\n  abstract destroy(): void;\n  protected buffer: Uint8Array;\n  protected buffer32: Uint32Array;\n  protected length: number = 0;\n  protected pos: number = 0;\n  protected finished = false;\n  protected destroyed = false;\n\n  constructor(\n    readonly blockLen: number,\n    public outputLen: number,\n    opts: BlakeOpts = {},\n    keyLen: number,\n    saltLen: number,\n    persLen: number\n  ) {\n    super();\n    assert.number(blockLen);\n    assert.number(outputLen);\n    assert.number(keyLen);\n    if (outputLen < 0 || outputLen > keyLen) throw new Error('outputLen bigger than keyLen');\n    if (opts.key !== undefined && (opts.key.length < 1 || opts.key.length > keyLen))\n      throw new Error(`key must be up 1..${keyLen} byte long or undefined`);\n    if (opts.salt !== undefined && opts.salt.length !== saltLen)\n      throw new Error(`salt must be ${saltLen} byte long or undefined`);\n    if (opts.personalization !== undefined && opts.personalization.length !== persLen)\n      throw new Error(`personalization must be ${persLen} byte long or undefined`);\n    this.buffer32 = u32((this.buffer = new Uint8Array(blockLen)));\n  }\n  update(data: Input) {\n    assert.exists(this);\n    // Main difference with other hashes: there is flag for last block,\n    // so we cannot process current block before we know that there\n    // is the next one. This significantly complicates logic and reduces ability\n    // to do zero-copy processing\n    const { blockLen, buffer, buffer32 } = this;\n    data = toBytes(data);\n    const len = data.length;\n    const offset = data.byteOffset;\n    const buf = data.buffer;\n    for (let pos = 0; pos < len; ) {\n      // If buffer is full and we still have input (don't process last block, same as blake2s)\n      if (this.pos === blockLen) {\n        this.compress(buffer32, 0, false);\n        this.pos = 0;\n      }\n      const take = Math.min(blockLen - this.pos, len - pos);\n      const dataOffset = offset + pos;\n      // full block && aligned to 4 bytes && not last in input\n      if (take === blockLen && !(dataOffset % 4) && pos + take < len) {\n        const data32 = new Uint32Array(buf, dataOffset, Math.floor((len - pos) / 4));\n        for (let pos32 = 0; pos + blockLen < len; pos32 += buffer32.length, pos += blockLen) {\n          this.length += blockLen;\n          this.compress(data32, pos32, false);\n        }\n        continue;\n      }\n      buffer.set(data.subarray(pos, pos + take), this.pos);\n      this.pos += take;\n      this.length += take;\n      pos += take;\n    }\n    return this;\n  }\n  digestInto(out: Uint8Array) {\n    assert.exists(this);\n    assert.output(out, this);\n    const { pos, buffer32 } = this;\n    this.finished = true;\n    // Padding\n    this.buffer.subarray(pos).fill(0);\n    this.compress(buffer32, 0, true);\n    const out32 = u32(out);\n    this.get().forEach((v, i) => (out32[i] = v));\n  }\n  digest() {\n    const { buffer, outputLen } = this;\n    this.digestInto(buffer);\n    const res = buffer.slice(0, outputLen);\n    this.destroy();\n    return res;\n  }\n  _cloneInto(to?: T): T {\n    const { buffer, length, finished, destroyed, outputLen, pos } = this;\n    to ||= new (this.constructor as any)({ dkLen: outputLen }) as T;\n    to.set(...this.get());\n    to.length = length;\n    to.finished = finished;\n    to.destroyed = destroyed;\n    to.outputLen = outputLen;\n    to.buffer.set(buffer);\n    to.pos = pos;\n    return to;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}